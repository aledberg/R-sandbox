---
title: "Simulation"
output:
  html_document:
    df_print: paged
urlcolor: blue
author: Anders Ledberg
---


```{r render, eval = FALSE, echo = FALSE}
library(rmarkdown)
## figure out the name of the current file (as this is the one we want to compile)
fname="./simulation.Rmd"
rmarkdown::render(fname, output_dir = "./",output_format=pdf_document())
```

# Introduction
This R Markdown file is about using R to generate data (simulating) according to a specified model. Perhaps this seems a bit backwards -- after all, you want to use R to analyze data you already have, not to generate new data -- but I believe that simulations can provide both a deeper understanding of the models we use, as well as providing a tool to test the impact of deviations from these model (sometimes called sensitivity analysis). 

## Making your own functions
A function (in R anyways) is a way to encapsulate a set of instructions in order to perform a particular task (not necessarily evaluating a mathematical function). We have already used many R-functions in the course. Let's look at some examples. 
```{r}
## base R has a function "sqrt" for computing the square root of a number
x <- 2.0
y=sqrt(x)
## we can then use the function "print" to see the contents of "y"
print(y)
## note that the syntax for calling a function uses parenthesis "()"
```
Now we will make our own function that calculates the square root of a positive real number. To do this we will use an *iterative* algorithm, that is, we start by guessing the answer and then gradually improve on this in a number of iterations. There are several iterative algorithms that can be used to find the square root, we will use the following 
\begin{align}
x_0 :=& y/2\\
x_i :=&\frac{1}{2}\left ( x_{i-1}+\frac{y}{x_{i-1}} \right ).
\end{align}
That this algorithm actually *converges* to the correct answer is not too hard to show, here we just note that $x=\sqrt(y)$ is a fixed point. According to Wikipedia this is known as the [Babylonian method](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method) and you can find hints of how to show converges on that site.

The following code chunk shows the basic syntax for defining your own functions:
```{r}
myfunction <- function(){
    print("This is my own function")
}
```
Once you have initialized the function (executed the R code) you can call this function exactly as any other 
```{r}
## call user-defined function
myfunction()
```

Now lets implement the square root function. 
```{r}
## square root of positive real number
mysqrt <- function(a){
    ## if a < 0 return immediately
    if(a < 0)
        return(NA)
    ## else we find the square root by an iterative method
    ## initial guess
    s <- a/2
    ## define how small we allow the error to be
    small <- 1.0e-10
    while (abs(s*s -a) >small){
        ## update s by the average of s and a/s
        s <- 1/2*(s+a/s)
    }
    return(s)
}
```
Lets now compare this function to the built in version

```{r}
## define the number to take the square root of
a <- 34.25
## print the results 
print(paste("system square root: ", sqrt(a), "; user defined: ", mysqrt(a)))
```

## Sampling random numbers

When simulating data it is often important to be able to sample from some particular distribution. Random sampling from the most common distributions is easy using R. Below we will sample from the standard normal and the uniform distributions as an example. 

```{r}
## draw one sample from standard normal distribution
rnorm(1)
## draw five samples from standard normal distribution
rnorm(5)
## draw one sample from the uniform distribution on [0,1]
runif(1)
## draw five samples from the uniform distribution on [0,1]
runif(5)
```
As you can notice by repeatedly executing the above code the numbers will be different each time. They are random! (or at least pseudo-random). If we draw many samples we can make a histogram to check that the sample conform to the desired distribution.

```{r}
## draw many samples from standard normal distribution
r <- rnorm(10000)
## plot a histogram using base R function hist()
hist(r,50)
```
It looks pretty normal. Let's change the mean and the standard deviation. 
```{r}
## standard normal
r1 <- rnorm(10000)
## change the mean value to 2, keep the default standard deviation
r2 <- rnorm(10000,2,1)
## keep the default mean (0) and change standard deviation to 2
r3 <- rnorm(10000,0,2)
## put data in a data frame for plotting with ggplot
df <- data.frame(data=r1,set=1)
df <- rbind(df,data.frame(data=r2,set=2))
df <- rbind(df,data.frame(data=r3,set=3))
```
Let's visualize these three sets of data using the density geom that we used in last class
```{r, echo=TRUE,fig.width=10, fig.height=6}
library(ggplot2)
ggplot(data=df,aes(x=data,color=factor(set),fill=factor(set))) +geom_density(alpha=0.1)
```

## A linear model

Consider a simple linear model where $y$ is a linear function of one independent variable $x$. We can represent this mathematically as 
$$
y_i=\mu + \beta x_i + \varepsilon_i.
$$
In words, for individual $i$ the value of $y_i$ is given by a constant $\mu$ (same for all persons), plus $\beta x_i$, where $\beta$ is a coefficient (slope), also same for all subjects, and $x_i$ is the (known) value of the independent variable for subject $i$, plus $\varepsilon_i$ which is a random term that takes care of everything in $y$ not explained by $x$. It is common to assume that the random terms (across all subjects) conform to some distribution, usually a normal distribution. 

We will now simulate data according the the linear model above. To do this we need to first decide on how many "subject" we want to simulate ($N$, say) and how to choose our independent variable ($x$). 
```{r}
## Number of subjects
N <- 1000
## sample the independent variables from a normal distribution with mean 180 and variance 50
m <- 180
v <- 50
x <- rnorm(N,mean=180,sd=sqrt(v))
```
Then we need to decide on values of $\mu$ (intercept) and $\beta$ (slope), and the variance of the noise term $\varepsilon_i$. This is conveniently done in a function. 
```{r}
## Define y as a linear function of x 
y <- function(x,mu=30,beta=.2,sigma=1){
    N <- length(x)
    y <- mu+beta*x+rnorm(N,0,sigma)
    return(y)
}
```
Now we can simulate data and plot $y$ as a function of $x$:

```{r}
## Define y as a linear function of x 
plot(x,y(x))
```
### Exercise: change the parameters of the model and see what happens
```{r}
## change parameters by changing the values below
mu=30
beta=-0.2
sigma=5
plot(x,y(x,mu,beta,sigma))
```

